package na.generics

import scala.reflect.runtime.universe._

import scala.reflect.{ClassTag, classTag}

/**
 * https://blog.knoldus.com/2018/04/02/type-erasure-in-scala/
 * http://docs.scala-lang.org/overviews/reflection/overview.html
 *
 * TypeTags can be thought of as objects which carry along all type information available at compile time, to runtime.
 * Though, it’s important to note that TypeTags are always generated by the compiler. This generation is triggered whenever
 * an implicit parameter or context bound requiring a TypeTag is used. This means that, typically, one can only obtain a
 * TypeTag using implicit parameters or context bounds.
 */
class Reflection {

    /**
     * A `ClassTag[T]` stores the erased class of a given type `T`, accessible via the `runtimeClass` field.
     *
     * ClassTags are a weaker special case of scala.reflect.api.TypeTags#TypeTags, in that they wrap only the runtime
     * class of a given type, whereas a TypeTag contains all static type information. That is, ClassTags are constructed
     * from knowing only the top-level class of a type, without necessarily knowing all of its argument types.
     *
     * This is particularly useful for instantiating `Array`s whose element types are unknown at compile time.
     */
    def createArray[A: ClassTag](seq: A*): Array[A] = Array[A](seq: _*)

    /**
     * ClassTag provides only the information needed to create types at runtime. I  f we ask for runtime class of List[Int],
     * we can see that information about Int that the list is parametrised with is lost i.e. they don’t care about type erasure.
     */
    def checkType[A: ClassTag](a: A): Class[_] = {
        classTag[A].runtimeClass
    }

    /**
     * If one wants “full” types, TypeTags should be used: method tpe of TypeTag results in a full type.
     *
     * The primary use case of TypeTag is to give access to erased types. Scala’s TypeTags can give us details
     * about type parameters that the Java compiler would normally erase.
     */
    def checkWithTypeTag[A: TypeTag](a: A): Type = {
        typeTag[A].tpe
    }

    def checkWithWeakTypeTag[A: WeakTypeTag](a: A): Type = {
        weakTypeTag[A].tpe
    }
}

object Reflection extends App {

    val test = new Reflection

    println("Array types ....... ")
    println(test.createArray(1,2))
    println(test.createArray("1","2"))

    //*********************************************
    println("check types with ClassTags ....... ")
    println(test.checkType(List()))
    println(test.checkType(List[Int]()))
    println(test.checkType(List[String]()))

    //*********************************************
    println("check types with TypeTags....... ")
    println(test.checkWithTypeTag(List()))
    println(test.checkWithTypeTag(List[Int]()))
    println(test.checkWithTypeTag(Int))
    println(test.checkWithTypeTag(new String))

    val k: Type = test.checkWithTypeTag(List[String]())

    println(k.decls.take(10))

    println(test.checkWithTypeTag(List))

    //*********************************************
    println("check types with WeakTypeTags....... ")

    println(test.checkWithWeakTypeTag(List()))
    println(test.checkWithWeakTypeTag(List))

    //println(test.checkWithWeakTypeTag(ReflectionTest))
}